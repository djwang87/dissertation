Analysis of familiar word recognition {#fam-rec}
========================================================================

```{r setup, include = FALSE}
d_m <- readr::read_csv("./data/aim1-model-ready.csv.gz")
knitr::read_chunk("./helpers.R")
if (interactive()) source("./helpers.R")
```

```{r helpers, include = FALSE, cache = FALSE}
```

```{r packages, include = FALSE}
library(rstanarm)
library(bayesplot)
theme_set(theme_teej())
library(stringr)
library(ggstance)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE)

b <- readr::read_rds("./data/stan_aim1_cubic_model.rds.gz")
b$stan_function <- "stan_glmer"

nsamples <- nrow(as.data.frame(b))
```



Growth curve analysis
------------------------------------------------------------------------

The outcome measure of interest here is how the probability of fixating
on the target image versus the distractors changes over time. There are
many possible techniques one can employ for modeling time series data.
In this chapter, I used growth curve analysis which uses polynomial
functions of time (a linear trend, a quadratic trend, etc.) to estimate
a time series. @Barr2008 and @Mirman2008 are important early tutorials
about this technique of modeling looking probabilities. (Incidentally,
the two articles were published together in a special issue of *Journal
of Memory and Language* about "emerging" statistical techniques.)
@Mirman2014 provides a textbook treatment of growth curve analysis for
eyetracking data. This approach is well suited for growth curves where
the trajectory is relatively simple with one or two inflection points.
One can forgo polynomial trends and use additive models to fit a more
general nonlinear shape. I apply this technique in
[Chapter \@ref(lex-competitors)](#lex-competitors) to handle wigglier
growth curve shapes. A third possibility is to use a nonlinear,
functional growth curve. For the polynomials and additive models,
underlying time features are weighted and summed to fit a nonlinear
shape. For the functional growth curve, the nonlinear shape is fixed in
advance and the model finds a set of parameters so the shape
approximates the data. For example, @bdots17 and @bdots18 model
eyetracking data by assuming an s-shaped curve (logistic function) and
then estimating the left and right asymptotes, slope at the steepest
point, and when the steepest point occurs. These parameters are directly
interpretable in terms of looking behaviors, but I have found that the
technique is not flexible enough to handle the noisier shapes of
children's eyetracking data.[^flex] For the following analyses,
therefore, I used polynomial growth curves.

[^flex]: More generally, I think of there being an
  flexibility--interpretability tradeoff with additive models being the
  most flexible but having the least interpretable parameters, functional
  curves being the least flexible but having the most interpretable
  parameter, polynomials falling in between the two.  




Looks to the familiar image were analyzed using Bayesian mixed effects
logistic regression. I used *logistic* regression because the outcome
measurement is a probability (the log-odds of looking to the target
image versus the distractors). I used *mixed-effects* models to estimate a
separate growth curve for each child (to measure individual differences
in word recognition) but also treat each child's individual growth curve
as a draw from a distribution of related curves. I used *Bayesian*
techniques to study a generative model of the data. Instead of reporting
and describing a single, best fit of some data, Bayesian methods
consider an entire distribution of plausible fits that are consistent
with the data and any prior information we have about the model
parameters. By using this approach, one can explicitly quantify
uncertainty about statistical effects and draw inferences using
estimates of uncertainty (instead of using statistical
significance—which is not a straightforward matter for mixed-effects
models).[^2]

[^2]: My goals in using this method were simply to estimate model 
    effects and quantify the uncertainty about those effects. This pragmatic, 
    estimation-based approach of Bayesian statistics is illustrated in texts 
    by @GelmanHill and @RethinkingBook.

Word recognition growth curves—that is, looks to the target versus the
distractors at 250 ms, 300 ms, etc.—were fit using an orthogonal cubic
polynomial function of time. Put differently, I modeled the probability
of looking to the target during an eyetracking task as:

$$
\text{log-odds}(\textit{looking}\,) = 
  \beta_0 + 
  \beta_1\text{Time}^1 + 
  \beta_2\text{Time}^2 + 
  \beta_3\text{Time}^3
$$

That the time terms are *orthogonal* means that $\text{Time}^1$,
$\text{Time}^2$ and $\text{Time}^3$ are transformed so that they
are uncorrelated. See Box 1. Under this formulation, the parameters $\beta_0$ and
$\beta_1$ have a direct interpretation in terms of lexical processing
performance. The intercept, $\beta_0$, measures the area under the
growth curve—or the probability of fixating on the target word averaged
over the whole window. We can think of $\beta_0$ as a measure of *word
recognition reliability*. The linear time parameter, $\beta_1$,
estimates the steepness of the growth curve—or how the probability of
fixating changes from frame to frame. We can think of $\beta_1$ as a
measure of *processing efficiency*, because growth curves with stronger
linear features exhibit steeper frame-by-frame increases in looking
probability.


\Begin{infobox}
<div class = "infobox">

**Box 1: Orthogonal time**.

I used orthogonal polynomial features of Time for these growth curve
models. Unlike natural polynomials, these features are uncorrelated.
This aspect makes these models more flexible: I do not have to worry
about any collinearity of Time^1^ between Time^2^. Moreover, adding an
orthogonal cubic Time^3^ term to a quadratic model will not change any
of the estimates for Time^1^ or Time^2^ because the added predictor is
not correlated with the others. One disadvantage of this approach is
that the features are not as straightforward to interpret. 

The figure below shows the orthogonal polynomials used by the model and
how they can be weighted and summed to fit a growth curve.

```{r infobox-ot-figs, message = FALSE, echo = FALSE, out.width = out_tex80_else66, fig.width = 6, fig.height = 3, fig.align = "center"}
t1_fam <- structure(
  list(
    Time = c(
      250, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800, 850, 900,
      950, 1000, 1050, 1100, 1150, 1200, 1250, 1300, 1350, 1400, 1450, 1500),
    Prop = c(
      0.252, 0.255, 0.257, 0.261, 0.265, 0.275, 0.286, 0.298, 0.311, 0.315,
      0.329, 0.342, 0.365, 0.392, 0.407, 0.422, 0.446, 0.464, 0.479, 0.497,
      0.514, 0.524, 0.532, 0.545, 0.549, 0.555)),
  .Names = c("Time", "Prop"),
  class = c("tbl_df", "tbl", "data.frame"),
  row.names = c(NA, -26L))

times <- t1_fam$Time %>% modelr::seq_range(80) 

t1_fam <- t1_fam %>% 
  polypoly::poly_add_columns(Time, 3, "ot", scale_width = 1)
t1_poly <- lm(Prop ~ ot1 + ot2 + ot3, data = t1_fam)

poly_basis <- times %>% 
  poly(3) %>% 
  polypoly::poly_rescale(scale_width = 1) %>% 
  polypoly::poly_melt() %>%
  mutate(Time = rep(times, 3))

p1 <- ggplot(poly_basis) +
  aes(x = Time, y = value) +
  geom_line(aes(color = degree)) +
  # ylim(c(-2, 2)) +
  guides(color = FALSE) +
  ggtitle("Basis functions (time features)") +
  labs(
    x = constants$x_time,
    y = NULL) +
  geom_text(
    aes(label = label, color = factor(degree)),
    data = data_frame(
      Time = c(1100, 850, 600),
      value = c(.32, -.42, .43),
      label = c("Time^1", "Time^2", "Time^3"),
      degree = c(1, 2, 3)),
    parse = TRUE,
    size = 4,
    family = "Lato Semibold") +
  theme_teej(base_size = 9)  +
  scale_y_continuous(breaks = c(-.5,  0,  .5)) +
  theme(
    plot.background = element_rect(
      fill = constants$col_infobox_blue,
      colour = constants$col_infobox_blue),
    panel.background = element_rect(fill = constants$col_infobox_plot_bg))

scaled <- t1_fam$Time %>% 
  modelr::seq_range(80) %>% 
  poly(3) %>% 
  polypoly::poly_rescale(scale_width = 1) 
  
poly_weighted <- (scaled %*% diag(coef(t1_poly)[-1])) %>%
  polypoly::poly_melt() %>%
  mutate(Time = rep(times, 3))

p2 <- ggplot(poly_weighted) +
  aes(x = Time, y = value) +
  geom_line(aes(color = factor(degree))) +
  stat_summary(
    fun.y = sum,
    color = constants$col_blue_highlight,
    geom = "line",
    size = 1.25) +
  geom_text(
    aes(label = label, color = factor(degree)),
    data = data_frame(
      Time = c(550, 500, 1200),
      value = c(-.05, .03, .04),
      label = c("Time^1", "Time^2", "Time^3"),
      degree = c(1, 2, 3)),
    parse = TRUE,
    size = 4,
    family = "Lato Semibold") +
  annotate("text",
           label = "sum", 
           x = 1340, 
           y = .175, 
           color = constants$col_blue_highlight,
           size = 4,
           family = "Lato Semibold") +
  ylim(c(-.2, .2)) +
  guides(color = FALSE) +
  ggtitle("Weighted basis functions") +
  labs(
    x = constants$x_time,
    y = NULL) +
  theme_teej(base_size = 9)  +
  theme(
    plot.background = element_rect(
      fill = constants$col_infobox_blue,
      colour = constants$col_infobox_blue),
    panel.background = element_rect(fill = constants$col_infobox_plot_bg))

p3 <- cowplot::plot_grid(p1, p2)
print(p3)
```

Note that the time features and weighted features are vertically
centered around 0. The curves are adjusted up or down to their correct
position by the model's intercept term. Conceptually, one can also think
of the intercept as a Time^0^ feature---that is, a horizontal line at
*y* = 1 which is weighted to move the whole curve vertically. This is
why in these models, the intercept is not the value at some time 0 but
rather the average value of the fitted growth curve. To reiterate, for
these word recognition models, the intercept is the average probability
of the curve. 

For all the polynomial growth curves models I used in this project, I
scaled the features so that Time^1^ ranges from −.5 to .5. In other
words, a 1-unit change on Time^1^ marks the whole traversal across the
analysis window. After scaling, Time^2^ ranges from −.33 to .60 and
Time^3^ ranges from −.63 to .63.

In my experience, only the intercept terms and linear time trends of an
orthogonal polynomial model have a behaviorally straightforward
interpretation. The polynomial other terms are less important—or rather,
they do not map as neatly onto behavioral descriptions as the accuracy
and efficiency parameters. The primary purpose of quadratic and cubic
terms is to ensure that the estimated growth curve adequately fits the
data. In this kind of data, there is a steady baseline at chance
probability before the child hears the word, followed a window of
increasing probability of fixating on the target as the child recognizes
the word, followed by a period of plateauing and then diminishing looks
to target. The cubic polynomial allows the growth curve to be fit with
two inflection points: the point when the looks to target start to
increase from baseline and the point when the looks to target stops
increasing.
</div>
\End{infobox}













To study how word recognition changes over time, I modeled how the
growth curves change over developmental time. This amounted to studying
how the growth curve parameters changes year over year. I included
dummy-coded indicators for Age 3, Age 4, and Age 5 and allowed these
indicators to interact with the growth curve parameters:

`r insert_html_math()`
\small
\begin{align*}
   \text{log-odds}(\mathit{looking}) =\
    &\beta_0 + 
      \beta_1\text{Time}^1 + 
      \beta_2\text{Time}^2 + 
      \beta_3\text{Time}^3\ + 
      &\text{[age 3 growth curve]} \\
    (&\gamma_{0} + 
      \gamma_{1}\text{Time}^1 + 
      \gamma_{2}\text{Time}^2 +
      \gamma_{3}\text{Time}^3)*\text{Age}\,\text{4} + \
      &\text{[adjustments for age 4]} \\
    (&\delta_{0}\!\ + 
      \delta_{1}\text{Time}^1\!\ + 
      \delta_{2}\text{Time}^2\!\ +
      \delta_{3}\text{Time}^3)*\text{Age}\,\text{5} \
      &\text{[adjustments for age 5]} \\
\end{align*}
\normalsize
`r insert_html_math()`

These year-by-growth-curve-feature terms captured how the shape of the growth
curves changed each year. The model also included random effects to
represent by-child and by-child-by-year effects to estimate a general
growth curve for each child and to estimate how each child's growth
curve changed each year.

The models were fit in R (vers. 3.4.3) with the RStanARM package
(vers. 2.16.3). [Appendix \@ref(aim1-gca-models)](#aim1-gca-models)
contains the R code used to fit the model along with a description of 
the model specifications represented in the model syntax.



### Growth curve features as measures of word recognition performance

As mentioned above, two of the model's growth curve features have
straightforward interpretations in terms of lexical processing
performance: The model's intercept parameter corresponds to the average
proportion or probability of looking to the named image over the trial
window, and the linear time parameter corresponds to slope of the growth
curve or lexical processing efficiency. I also was interested in *peak*
proportion of looks to the target. I derived this value by computing the
growth curves from the model and taking the median of the five highest
points on the curve. Figure \@ref(fig:curve-features) shows three
simulated growth curves and how each of these growth curve features
relate to word recognition performance.

(ref:curve-features) Illustration of the three growth curve features and how they describe lexical processing performance. The three curves used are simulations of new participants at Age 4.

(ref:curve-features-scap) Illustration of the three growth curve features and how they describe lexical processing performance.

```{r curve-features, fig.cap = "(ref:curve-features)", fig.scap="(ref:curve-features-scap)", echo = FALSE, out.width = out_tex100_else80, fig.height = 5, fig.width = 5}
dummy_data <- d_m %>% 
  filter(Study == "TimePoint2") %>% 
  distinct(Study, Time, ot1, ot2, ot3) %>% 
  mutate(
    ResearchID = "NEW", 
    Primary = 0, 
    Others = 0)

set.seed(02062018)

lpred <- dummy_data %>% 
  tristan::augment_posterior_linpred(model = b, newdata = ., nsamples = 3) 
lpred_lm <- lpred %>% 
  tidyr::nest(-.draw) %>% 
  mutate(
    model = purrr::map(data, ~ lm(.posterior_value ~ ot1 + ot2 + ot3, .x)),
    coef = lapply(model, coef),
    auc = purrr::map_dbl(coef, purrr::pluck, 1),
    slope = purrr::map_dbl(coef, purrr::pluck, 2),
    time2 = purrr::map_dbl(coef, purrr::pluck, 3),
    time3 = purrr::map_dbl(coef, purrr::pluck, 4)) %>% 
  select(-model, -coef) %>% 
  tidyr::unnest(data) %>% 
  # Sort using the AUC values
  mutate(.draw = forcats::fct_reorder(as.factor(.draw), auc))

subtheme <- theme_teej(base_size = 10)

p1 <- ggplot(lpred_lm) + 
  aes(x = ot1, y = .posterior_value, group = .draw) + 
  geom_line(linetype = "dashed", color = constants$col_off_black) + 
  geom_hline(
    aes(yintercept = auc), 
    color = constants$col_blue_highlight, 
    size = .75) + 
  labs(
    x = NULL,
    y = constants$y_logodds_target,
    title = "Intercept term represents average probability") + 
  facet_wrap(".draw") + 
  subtheme +
  theme(
    strip.text = element_blank(), 
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank())

p2 <- ggplot(lpred_lm) + 
  aes(x = ot1, y = .posterior_value, group = .draw) + 
  geom_line(linetype = "dashed", color = constants$col_off_black) + 
  geom_abline(
    aes(intercept = auc, slope = slope),
    color = constants$col_blue_highlight, 
    size = .75) + 
  facet_wrap(".draw") + 
  labs(
    x = NULL,
    y = constants$y_logodds_target,
    title = "Linear time term represents processing efficiency") +
  subtheme +
  theme(
    strip.text = element_blank(), 
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.y = element_blank())

p3 <- ggplot(lpred_lm) + 
  aes(x = ot1, y = .posterior_value, group = .draw) + 
  geom_line(linetype = "dashed", color = constants$col_off_black) + 
  geom_point(
    data = lpred_lm %>% group_by(.draw) %>% top_n(5, .posterior_value), 
    size = 2, color = constants$col_off_black) + 
  geom_hline(
    aes(yintercept = .posterior_value), 
    data = lpred_lm %>% 
      group_by(.draw) %>% 
      top_n(5, .posterior_value) %>% 
      summarise(.posterior_value = median(.posterior_value)), 
    size = .75, 
    color = constants$col_blue_highlight) + 
  facet_wrap(".draw") + 
  labs(
    x = constants$x_time,
    y = constants$y_logodds_target,
    title = "Peak probability is derived from median of top five points") + 
  subtheme +
  theme(
    strip.text = element_blank(), 
    axis.text.x = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.x = element_blank())

library(patchwork)
p1 + p2 + p3 + plot_layout(ncol = 1)
```

```{r poster-version-of-features, eval = FALSE, include = FALSE}
library(extrafont)

dummy_data <- d_m %>%
  filter(Study == "TimePoint2") %>%
  distinct(Study, Time, ot1, ot2, ot3) %>%
  mutate(
    ResearchID = "NEW",
    Primary = 0,
    Others = 0)

set.seed(02062018)

lpred <- dummy_data %>%
  tristan::augment_posterior_linpred(model = b, newdata = ., nsamples = 3)

lpred_lm <- lpred %>%
  tidyr::nest(-.draw) %>%
  mutate(
    model = purrr::map(data, ~ lm(.posterior_value ~ ot1 + ot2 + ot3, .x)),
    coef = lapply(model, coef),
    auc = purrr::map_dbl(coef, purrr::pluck, 1),
    slope = purrr::map_dbl(coef, purrr::pluck, 2),
    time2 = purrr::map_dbl(coef, purrr::pluck, 3),
    time3 = purrr::map_dbl(coef, purrr::pluck, 4)) %>%
  select(-model, -coef) %>%
  tidyr::unnest(data) %>%
  # Sort using the AUC values
  mutate(.draw = forcats::fct_reorder(as.factor(.draw), auc))

lpred_lm <- lpred_lm %>%
  filter(.draw == 2)

theme_poster <- theme_grey(base_size = 14, base_family = "Lato")

p1 <- ggplot(lpred_lm) +
  aes(x = ot1, y = .posterior_value, group = .draw) +
  geom_line(linetype = "dashed", color = constants$col_off_black) +
  geom_point(
    data = lpred_lm %>% group_by(.draw) %>% top_n(5, .posterior_value),
    size = 2, color = constants$col_off_black) +
  geom_hline(
    aes(yintercept = .posterior_value),
    data = lpred_lm %>%
      group_by(.draw) %>%
      top_n(5, .posterior_value) %>%
      summarise(.posterior_value = median(.posterior_value)),
    size = .75,
    color = constants$col_blue_highlight) +
  annotate(
    geom = "text", x = -.20, y = -.66,  color = constants$col_off_black,
    label = "growth curve estimated\nfor each child x study", family = "Lato",
    size = 3.5, vjust = 1, hjust = 0) +
  annotate(
    geom = "text", x = -.50, y = .9,  color = constants$col_blue_highlight,
    label = "curve feature", family = "Lato",
    size = 3.5, vjust = 1, hjust = 0) +
  labs(
    x = NULL,
    y = constants$y_logodds_target,
    title = "Peak probability") +
  theme_poster +
  theme(
    strip.text = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.title.y = element_text(hjust = 1),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank())

p2 <- ggplot(lpred_lm) +
  aes(x = ot1, y = .posterior_value, group = .draw) +
  geom_line(linetype = "dashed", color = constants$col_off_black) +
  geom_hline(
    aes(yintercept = auc),
    color = constants$col_blue_highlight,
    size = .75) +
  labs(
    x = NULL,
    y = constants$y_logodds_target,
    title = "Average probability") +
  theme_poster +
  theme(
    strip.text = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank())

p3 <- ggplot(lpred_lm) +
  aes(x = ot1, y = .posterior_value, group = .draw) +
  geom_line(linetype = "dashed", color = constants$col_off_black) +
  geom_abline(
    aes(slope = slope, intercept = auc),
    color = constants$col_blue_highlight,
    size = .75) +
  labs(
    x = NULL,
    y = NULL,
    title = "Linear trend") +
  theme_poster +
  theme(
    strip.text = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank())

p4 <- ggplot(lpred_lm) +
  aes(x = ot1, y = .posterior_value, group = .draw) +
  geom_line(linetype = "dashed", color = constants$col_off_black) +
  geom_line(
    aes(y = ot2 * time2 + auc),
    color = constants$col_blue_highlight,
    size = .75) +
  labs(
    x = NULL,
    y = NULL,
    title = "Quadratic trend") +
  theme_poster +
  theme(
    strip.text = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank()) 

p5 <- ggplot(lpred_lm) +
  aes(x = ot1, y = .posterior_value, group = .draw) +
  geom_line(
    linetype = "dashed", color = constants$col_off_black,
    data = lpred_lm %>% filter(.posterior_value <= -.97)) +
  geom_line(
    linetype = "dashed", color = constants$col_off_black,
    data = lpred_lm %>% filter(-.68 <= .posterior_value)) +
  geom_line(
    aes(y = ot3 * time3 + auc),
    color = constants$col_blue_highlight,
    size = .75) +
  labs(
    x = constants$x_time,
    y = NULL,
    title = "Cubic trend") +
  theme_poster +
  theme(
    strip.text = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.title.x = element_text(hjust = 1),
    axis.ticks.x = element_blank(),
    axis.ticks.y = element_blank()) +   
  annotate(
    geom = "text", x = -1.25, y = -.66,  color = constants$col_off_black,
    label = "(These two features capture the curve shape\nand tend not to be behaviorally meaningful.)", 
    family = "Lato",
    size = 3.5, vjust = 1, hjust = 0)  + 
  coord_cartesian(clip = "off", xlim = c(-.5, .5))

library(patchwork)
p1 + p2 + p3 + p4 + p5 + plot_layout(nrow = 1)
tjmisc::ggpreview(width = 12, height = 3.5, dpi = 600)
```



Year over year changes in word recognition performance
------------------------------------------------------------------------

The mixed-effects model estimated a population-average growth curve
("fixed" effects) and how individual children deviated from average
("random" effects). Figure \@ref(fig:average-growth-curves) shows 200
posterior samples of the average growth curves for each study. On
average, the growth curves become steeper and achieve higher looking
probabilities with each year of the study.

(ref:average-growth-curves) Population-average ("fixed effects") word recognition growth curves at each age. Colored lines represent 200 posterior samples of these growth curves; these are included to visualize the uncertainty about the population averages. The thick light lines represent the observed average growth curve in each study.

(ref:average-growth-curves-scap) Population-average ("fixed effects") word recognition growth curves at each age.

```{r average-growth-curves, fig.cap = "(ref:average-growth-curves)", fig.scap = "(ref:average-growth-curves-scap)", echo = FALSE, out.width = out_tex80_else50, fig.height = 3, fig.width = 4}
dummy_data <- d_m %>% 
  distinct(Study, Time, ot1, ot2, ot3) %>% 
  mutate(
    ResearchID = "NEW", 
    Primary = 0, 
    Others = 0)

set.seed(11102017)
lpred <- dummy_data %>% 
  tristan::augment_posterior_linpred(model = b, newdata = ., re.form = NA)

peaks <- lpred %>% 
  group_by(Study, .draw) %>% 
  top_n(5, .posterior_value) %>% 
  mutate(med = median(.posterior_value)) %>% 
  select(.draw, Study, peek_accuracy = med) %>% 
  distinct() %>% 
  ungroup() %>% 
  mutate(peek_accuracy = peek_accuracy) %>% 
  tidyr::spread(Study, peek_accuracy) %>% 
  select(
    `Peak~~(Age~~3)` = TimePoint1,
    `Peak~~(Age~~4)` = TimePoint2,
    `Peak~~(Age~~5)` = TimePoint3)

lpred %>% 
  tjmisc::sample_n_of(200, .draw) %>% 
  mutate(Study = convert_study_to_age(Study)) %>% 
  ggplot() + 
    aes(x = Time, y = plogis(.posterior_value), color = Study) +
    geom_hline(yintercept = .25, color = "white", size = 2) +
    geom_line(
      aes(group = interaction(Study, ResearchID, .draw)), 
      alpha = .05) +
    stat_summary(
      aes(y = Prop, group = Study), 
      data = d_m %>% 
        mutate(Study = convert_study_to_age(Study)), 
      fun.y = "mean", 
      geom = "line", 
      color = scales::viridis_pal(end = 1)(3)[3],
      size = 1) + 
    geom_text(
      aes(label = Study, y = y), 
      data = data_frame(Time = 1390, y = .83, Study = "Age 5"),
      size = 5,
      family = "Lato Semibold") +
    geom_text(
      aes(label = Study, y = y), 
      data = data_frame(Time = 1380, y = .46, Study = "Age 3"),
      family = "Lato Semibold", 
      size = 5) +
    expand_limits(y = .85) +
    scale_color_study() +
    guides(color = "none") +
    labs(
      title = "Observed means and 200 posterior fits",
      x = constants$x_time,
      y = constants$y_prop_target)
```


```{r poster-version-of-averages, eval = FALSE, include = FALSE}
lpred <- lpred %>% 
  select(-(ot1:Others)) %>% 
  select(Study, Time, everything())

lpred_intervals <- lpred %>% 
  select(Study, Time, .posterior_value) %>%
  mutate(.posterior_value = plogis(.posterior_value)) %>% 
  tidyr::nest(-Time, -Study) %>% 
  mutate(intervals = purrr::map(data, bayesplot::mcmc_intervals_data)) %>% 
  select(-data) %>% 
  tidyr::unnest(intervals) %>% 
  mutate(
    Study = convert_study_to_age(Study),
    Facet = "Averages from model")

d_m %>% 
  mutate(Study = convert_study_to_age(Study), Facet = Study) %>% 
  ggplot() + 
    aes(x = Time, y = Prop) + 
    geom_hline(yintercept = .25, color = "white", size = 2) + 
    geom_line(
      aes(group = ResearchID), 
      alpha = .16, 
      color = constants$col_off_black) + 
    stat_summary(
      fun.y = mean, 
      geom = "line", 
      size = 1.25, 
      color = constants$col_blue_highlight) +
    geom_ribbon(
      aes(y = NULL, ymin = ll, ymax = hh, group = Study), 
      data = lpred_intervals, 
      alpha = .2) +
    geom_line(
      aes(y = m, group = Study), 
      data = lpred_intervals, 
      size = 1.25, 
      color = constants$col_blue_highlight) +
    geom_text(
      aes(label = "Age 5"), 
      x = 1360, 
      y = .835, 
      family = "Lato", 
      size = 5,
      data = data.frame(Facet = "Averages from model")) +
    geom_text(
      aes(label = "Age 3"), 
      x = 1340, 
      y = .42, 
      family = "Lato", 
      size = 5,
      data = data.frame(Facet = "Averages from model")) +
    facet_grid(. ~ Facet) + 
    labs(
      x = constants$x_time,
      y = constants$y_prop_target,
      caption = 
        "One line: One child's raw data. Heavy lines: Study averages.") + 
    theme_grey(base_size = 18, base_family = "Lato") + 
    theme(
      axis.title.x = element_text(hjust = 1), 
      axis.title.y = element_text(hjust = 1),
      strip.background = element_blank(),
      strip.text = element_text(
        size = 18,
        hjust = 0, 
        margin = margin(0, 0, 7.2, 0, "pt")))

tjmisc::ggpreview(width = 12, height = 5, dpi = 600)
```

Figure \@ref(fig:effects2) depicts uncertainty intervals with
the model's average effects of each timepoint on the growth curve
features. The intercept and linear time effects increased each year,
confirming that children become more reliable and faster at recognizing
words as they grow older. The peak probability also increased each year.
For each effect, the change from age 3 to age 4 is approximately the
same as the change from age 4 to age 5, as illustrated in
Figure \@ref(fig:pairwise-effects).

(ref:effects2) Uncertainty intervals for growth curve features at each age. The intercept and peak features were converted from log-odds to proportions to ease interpretation.

(ref:effects2-scap) Uncertainty intervals for growth curve features at each age.

```{r effects2, fig.cap = "(ref:effects2)", fig.scap = "(ref:effects2-scap)", echo = FALSE, out.width = "100%", fig.height=4, fig.width=8}
# Column names will have mathematical formatting too
draws <- as.data.frame(b) %>% 
  as_tibble() %>% 
  transmute(
    `Intercept~~(Age~~3)` = `(Intercept)`,
    `Intercept~~(Age~~4)` = `(Intercept)` + StudyTimePoint2,
    `Intercept~~(Age~~5)` = `(Intercept)` + StudyTimePoint3,
    `Time~~(Age~~3)` = ot1,
    `Time~~(Age~~4)` = ot1 + `ot1:StudyTimePoint2`,
    `Time~~(Age~~5)` = ot1 + `ot1:StudyTimePoint3`,
    `Time^2~~(Age~~3)` = ot2,
    `Time^2~~(Age~~4)` = ot2 + `ot2:StudyTimePoint2`,
    `Time^2~~(Age~~5)` = ot2 + `ot2:StudyTimePoint3`,
    `Time^3~~(Age~~3)` = ot3,
    `Time^3~~(Age~~4)` = ot3 + `ot3:StudyTimePoint2`,
    `Time^3~~(Age~~5)` = ot3 + `ot3:StudyTimePoint3`) %>% 
  bind_cols(peaks)

logodds <- draws %>% 
  select(starts_with("Time")) %>% 
  mcmc_intervals_data(prob = 0.5, prob_outer = 0.9) %>% 
  mutate(Scale = "Log-odds") %>% 
  mutate(parameter = factor(parameter, levels = rev(names(draws))))

props <- draws %>% 
  select(starts_with("Intercept"), starts_with("Peak")) %>% 
  mutate_all(plogis) %>% 
  mcmc_intervals_data(prob = 0.5, prob_outer = 0.9) %>% 
  mutate(Scale = "Proportion") %>% 
  mutate(parameter = factor(parameter, levels = rev(names(draws))))

intervals2 <- bind_rows(props, logodds) %>% 
  group_by(Scale) %>% 
  mutate(min_x = min(ll), max_x = max(hh)) %>% 
  ungroup()

p1 <- intervals2 %>% 
  filter(Scale != "Proportion") %>% 
  ggplot() + 
    aes(y = parameter) +
    geom_vline(xintercept = 0, size = 2, color = "white") +
    geom_point(aes(x = m), size = 3, shape = 3) + 
    # Draw mock gridlines in case the point's + shape is wider than interval.
    # All that's visible is then a | with a gap in the middle.
    geom_segment(
      aes(y = parameter, yend = parameter, x = min_x, xend = max_x), 
      size = .25, color = "white") +
    ggstance::geom_linerangeh(aes(xmin = ll, xmax = hh)) + 
    ggstance::geom_linerangeh(aes(xmin = l, xmax = h), size = 2) +
    scale_y_discrete(labels = parse_text) + 
    labs(
      x = NULL, 
      y = NULL, 
      title = "Average effects by study",
      caption = " ") 

p2 <- p1 %+% (intervals2 %>% filter(Scale == "Proportion"))
p2 <- p2 + 
  labs(title = " ", caption = constants$cap_median_90_50) 
p3 <- ggplot() + theme_void()

p23 <- cowplot::plot_grid(p2, p3, ncol = 1, rel_heights = c(.66, .33))
cowplot::plot_grid(p1, p23, ncol = 2)
```

(ref:pairwise-effects) Uncertainty intervals for the differences in growth curve features between ages. Again, the intercept and peak features were converted to proportions.

(ref:pairwise-effects-scap)  Uncertainty intervals for the differences in growth curve features between ages.

```{r pairwise-effects, fig.cap = "(ref:pairwise-effects)", fig.scap = "(ref:pairwise-effects-scap)",  fig.show = 'hold', echo = FALSE, out.width = "100%", fig.height = c(4), fig.width = c(8)}
clean_names <- . %>% 
  stringr::str_replace_all("[()]", "") %>% 
  stringr::str_replace("Age~~", "Age ") %>% 
  stringr::str_replace("~~", "_") %>% 
  stringr::str_replace("TP1", "Age 3") %>% 
  stringr::str_replace("TP2", "Age 4") %>% 
  stringr::str_replace("TP3", "Age 5")

pairwise <- draws %>% 
  mutate_at(vars(starts_with("Intercept"), starts_with("Peak")), plogis) %>% 
  tibble::rowid_to_column(".draw") %>% 
  set_names(clean_names) %>% 
  tidyr::gather(parameter, value, -.draw) %>% 
  tidyr::separate(parameter, c("parameter", "year"), sep = "_") %>% 
  compare_pairs(year, value) %>% 
  tidyr::spread(pair, value) %>% 
  split(.$parameter) %>% 
  lapply(
    . %>% select(-.draw, -parameter) %>% 
      mcmc_intervals_data(prob = 0.5, prob_outer = 0.9) %>% 
      rename(pair = parameter)) %>% 
  bind_rows(.id = "parameter") %>% 
  mutate(
    # Using phantom(l) to create a thin space between Age and the number
    # Using a factor to set the sorting order
    pair = pair %>% 
      stringr::str_replace_all("Age (\\d)", "paste(Age, phantom(l), \\1)") %>% 
      factor(c(
        "paste(Age, phantom(l), 4)-paste(Age, phantom(l), 3)", 
        "paste(Age, phantom(l), 5)-paste(Age, phantom(l), 4)", 
        "paste(Age, phantom(l), 5)-paste(Age, phantom(l), 3)")))

pairwise$parameter <- ifelse(
  pairwise$parameter == "Time",
  "Time^phantom(1)",
  pairwise$parameter) %>%
  factor(levels = c("Intercept", "Peak", "Time^phantom(1)", "Time^2", "Time^3"))

p1 <- ggplot(pairwise %>% filter(!(parameter %in% c("Peak", "Intercept")))) + 
  aes(y = forcats::fct_rev(pair)) +
  geom_vline(xintercept = 0, size = 2, color = "white") +
  ggstance::geom_linerangeh(aes(xmin = ll, xmax = hh)) + 
  ggstance::geom_linerangeh(aes(xmin = l, xmax = h), size = 2) +
  geom_point(aes(x = m), size = 3, shape = 3) + 
  facet_wrap(
    facets = "parameter", 
    ncol = 1, 
    strip.position = "left", 
    labeller = label_parsed) + 
  scale_y_discrete(labels = parse_text) + 
  labs(
    x = NULL, 
    y = NULL, 
    title = "Differences in average effects",
    caption = " ") + 
  theme_grey() +
  # theme_teej() +
  theme(
    strip.placement = "outside", 
    strip.background = element_rect(fill = NA),
    axis.text.y = element_text(size = rel(1.2)),
    strip.text.y = element_text(
      # hjust = .5,
      margin = margin(0, 10, 0, 5, "pt"),
      size = rel(1.4)))

p2 <- ggplot(pairwise %>% filter(parameter %in% c("Peak", "Intercept"))) + 
  aes(y = forcats::fct_rev(pair)) +
  geom_vline(xintercept = 0, size = 2, color = "white") +
  ggstance::geom_linerangeh(aes(xmin = ll, xmax = hh)) + 
  ggstance::geom_linerangeh(aes(xmin = l, xmax = h), size = 2) +
  geom_point(aes(x = m), size = 3, shape = 3) + 
  facet_wrap(
    facets = "parameter", 
    ncol = 1, 
    strip.position = "left", 
    labeller = label_parsed) + 
  scale_y_discrete(labels = parse_text) + 
  labs(
    x = NULL, 
    y = NULL, 
    title = "  ",
    caption = constants$cap_median_90_50) +
  theme_grey() +
  theme(
    strip.placement = "outside", 
    strip.background = element_rect(fill = NA),
    axis.text.y = element_text(size = rel(1.2)),
    strip.text.y = element_text(
      # hjust = .5,
      margin = margin(0, 10, 0, 5, "pt"),
      size = rel(1.4)))

p3 <- ggplot() + theme_void()
p23 <- cowplot::plot_grid(p2, p3, ncol = 1, rel_heights = c(.72, .28))
cowplot::plot_grid(p1, p23, ncol = 2)
# p23 <- p2 + plot_spacer() + plot_layout(ncol = 1, heights = c(4, 2))
# p1 + p23 + plot_layout(ncol = 2, widths = c(2, 2)) + plot_annotation(caption = constants$cap_median_90_50)
```

```{r, include = FALSE}
props <- props %>% 
  mutate(
    parameter = parameter %>% 
      stringr::str_replace("~~.", "_") %>% 
      stringr::str_replace("\\)", "")) %>% 
  tidyr::separate(parameter, sep = "_", into = c("parameter", "study"))

prop_diffs <- pairwise %>% 
  filter(parameter %in% c("Intercept", "Peak"))

prop_list1 <- props %>% 
  filter(parameter == "Intercept") %>% 
  split(.$study) %>% 
  set_names(str_extract, "Age~~.") %>% 
  set_names(str_replace, "~~", "")

prop_list2 <- props %>% 
  filter(parameter == "Peak") %>% 
  split(.$study) %>% 
  set_names(str_extract, "Age~~.") %>% 
  set_names(str_replace, "~~", "")

int_pts <- get_pts(prop_list1)
int_uis <- get_uis(prop_list1)
peak_pts <- get_pts(prop_list2)
peak_uis <- get_uis(prop_list2)

diff_list1 <- prop_diffs %>% 
  filter(parameter == "Intercept") %>% 
  split(.$pair) %>% 
  set_names(str_replace_all, ".+(\\d).+(\\d).+", "Age\\1_\\2")

diff_list2 <- prop_diffs %>% 
  filter(parameter == "Peak") %>% 
  split(.$pair) %>% 
  set_names(str_replace_all, ".+(\\d).+(\\d).+", "Age\\1_\\2")

int_dpts <- get_pts(diff_list1)
int_duis <- get_uis(diff_list1)
peak_dpts <- get_pts(diff_list2)
peak_duis <- get_uis(diff_list2)
```

The average looking probability (intercept feature) was `r int_pts$Age3`
[90% UI: `r int_uis$Age3`] at age 3, `r int_pts$Age4`
[`r int_uis$Age4`] at age 4, and `r int_pts$Age5` [`r int_uis$Age5`] at
age 5. The averages increased by `r int_dpts$Age4_3`
[`r int_duis$Age4_3`] from age 3 to age 4 and by `r int_dpts$Age5_4`
[`r int_duis$Age5_4`] from age 4 to age 5. The peak looking
probability was `r peak_pts$Age3` [`r peak_uis$Age3`] at age 3,
`r peak_pts$Age4` [`r peak_uis$Age4`] at age 4, and `r peak_pts$Age5`
[`r peak_uis$Age5`] at age 5. The peak values increased by
`r peak_dpts$Age4_3` [`r peak_duis$Age4_3`] from age 3 to age 4 and
by `r peak_dpts$Age5_4` [`r peak_duis$Age5_4`] from age 4 to age 5.
These results numerically confirm the hypothesis that children would
improve in their word recognition reliability, both in terms of average
looking and in terms of peak looking, each year. The changes in peak 
probability were also rather large: children's probability fixating on
the target increased by approximately .1 each year. These growths
indicate the task scaled with children's development because they had
room to improve each year.

**Summary**. The average growth curve features increased year over year,
so that children looked to the target more quickly and more reliably 
as they grew older.



Exploring plausible ranges of performance over time
------------------------------------------------------------------------

```{r, include = FALSE}
dummy_data <- d_m %>% 
  distinct(Study, Time, ot1, ot2, ot3) %>% 
  mutate(ResearchID = "NEW",
         Primary = 0, 
         Others = 0)

set.seed(11102017)
lpred <- dummy_data %>% 
  tristan::augment_posterior_linpred(b, newdata = ., nsamples = 1000)

new_peaks <- lpred %>% 
  mutate(Study = convert_study_to_age(Study)) %>% 
  distinct(.draw, .posterior_value, Study) %>% 
  group_by(Study, .draw) %>% 
  top_n(5, .posterior_value) %>% 
  summarise(peak = median(.posterior_value)) %>% 
  ungroup() %>% 
  mutate(peak = plogis(peak)) %>% 
  tidyr::spread(Study, peak) %>% 
  select(-.draw) %>% 
  mcmc_intervals_data(prob = 0.5, prob_outer = 0.9)

new_peaks_pts <- new_peaks %>% 
  split(.$parameter) %>% 
  get_pts() %>% 
  set_names(str_replace, " ", "")

new_peaks_uis <- new_peaks %>% 
  split(.$parameter) %>% 
  get_uis() %>% 
  set_names(str_replace, " ", "")

new_peaks_diff <- new_peaks %>% 
  split(.$parameter) %>% 
  lapply(function(l) round(l$hh - l$ll, 2)) %>% 
  set_names(str_replace, " ", "")
```

Bayesian models are generative; they describe how the data could have
been generated. This model assumed that each child's growth curve was
drawn from a population of related growth curves, and it tried to infer
the parameters over that distribution. These two aspects---a generative
model and learning about the population of growth curves---allow the
model to simulate new samples from that distribution of growth curves.
That is, we can predict a set of growth curves for a hypothetical,
unobserved child drawn from the same distribution as the
`r n_distinct(d_m$ResearchID)` children observed in this study. This
procedure of studying model implications by having the model generate
new data is called *posterior predictive inference*, and in this case,
it allows one to explore the plausible degrees of variability in
performance at each age.

Figure \@ref(fig:new-participants) shows the posterior predictions
for 1,000 simulated participants, and it demonstrates how the model
expects new participants to improve longitudinally but also exhibit
stable individual features over time. 
Figure \@ref(fig:new-participants-intervals) shows uncertainty intervals
for these simulations. The model learned to predict less accurate and
more variable performance at age 3 with improving accuracy and narrowing
variability at age 4 and age 5.

(ref:new-participants) Posterior predictions for hypothetical *unobserved* participants. Each line represents the predicted performance for a new participant. The three light lines highlight predictions from one single simulated participant. The simulated participant shows both longitudinal improvement in word recognition and similar relative performance compared to other simulations each year, indicating that the model would predict new children to improve year over year and show stable individual differences over time.

(ref:new-participants-scap) Posterior predictions for hypothetical *unobserved* participants. 

```{r new-participants, echo = FALSE, fig.cap = "(ref:new-participants)", fig.scap = "(ref:new-participants-scap)", fig.width = 6, fig.height = 3, out.width = out_tex100_else80}
ggplot(lpred %>% mutate(Study = convert_study_to_age(Study))) + 
  aes(x = Time, y = plogis(.posterior_value), color = Study) +
  geom_hline(yintercept = .25, size = 2, color = "white") +
  geom_line(
    aes(group = interaction(Study, .draw)), 
    alpha = .07, show.legend = FALSE) +
  geom_line(
    aes(group = interaction(Study, .draw)), 
    data = lpred %>% 
      sample_n_of(1, .draw) %>% 
      mutate(Study = convert_study_to_age(Study)), 
    color = scales::viridis_pal(end = 1)(3)[3],
    size = 1,
    show.legend = FALSE) +
  facet_wrap("Study") + 
  scale_color_study() +
  guides(color = guide_legend("none")) +
  labs(
    title = "Posterior predictions for 1,000 new participants",
    x = constants$x_time,
    y = constants$y_prop_target)
```

(ref:new-participants-intervals) Uncertainty intervals for the simulated participants. Variability is widest at age 3 and narrowest at age 5, consistent with the prediction that children become less variable as they grow older.

(ref:new-participants-intervals-scap) Uncertainty intervals for the simulated participants. 

```{r new-participants-intervals, echo = FALSE, fig.cap = "(ref:new-participants-intervals)", fig.scap = "(ref:new-participants-intervals-scap)", fig.width = 6, fig.height = 3, out.width = out_tex100_else80}
ggplot(lpred %>% mutate(Study = convert_study_to_age(Study))) + 
  aes(x = Time, y = plogis(.posterior_value), color = Study) +
  geom_hline(yintercept = .25, size = 2, color = "white") +
  stat_summary(
    fun.data = median_hilow, 
    fun.args = list(conf.int = .9),
    size = 1, 
    geom = "linerange") + 
  stat_summary(
    fun.data = median_hilow, 
    fun.args = list(conf.int = .5), 
    size = 1.5, 
    geom = "linerange") + 
  facet_wrap("Study") + 
  scale_color_study() +
  guides(color = guide_legend("none")) +
  labs(
    title = "Posterior predictions for 1,000 new participants",
    x = constants$x_time,
    y = constants$y_prop_target,
    caption = constants$cap_median_90_50)
```

I hypothesized that children would become less variable as they grew
older and converged on a mature level of performance. To address this
question, I inspected the ranges of predictions for the simulated
participants. The claim that children become less variable would imply
that the range of predictions should be narrower for age 5 than for age 4
and narrower for age 4 than for age 3. Figure \@ref(fig:new-ranges)
depicts the range of the predictions, both in terms of the 90-percentile
range (i.e., the range of the middle 90% of the data) and in terms of
the 50-percentile (interquartile) range. The ranges of performance
decrease from age 3 to age 4 to age 5, consistent with the hypothesized
reduction in variability.

(ref:new-ranges) Ranges of predictions for simulated participants over the course of a trial. The ranges are most similar during the first half of the trial when participants are at chance performance, and the ranges are most different at the end of the trial as children reliably fixate on the target image. The ranges of performance decreases with each year of the study as children show less variability.

(ref:new-ranges-scap) Ranges of predictions for simulated participants over the course of a trial.

```{r new-ranges, echo = FALSE, fig.cap = "(ref:new-ranges)", fig.scap = "(ref:new-ranges-scap)", fig.width = 6, fig.height = 3, out.width = out_tex100_else80}
by_draw <- lpred %>%
  group_by(Study, Time) %>%
  summarise(
    `95th` = quantile(plogis(.posterior_value), .95),
    `05th` = quantile(plogis(.posterior_value), .05),
    `75th` = quantile(plogis(.posterior_value), .75),
    `25th` = quantile(plogis(.posterior_value), .25),
    `95^th~vs.~05^th` = `95th` - `05th`,
    `75^th~vs.~25^th` = `75th` - `25th`) %>% 
  select(-matches("^..th$")) %>% 
  ungroup() %>% 
  tidyr::gather("range", "extent", -Study, -Time) %>% 
  mutate(range = factor(range, levels = unique(rev(sort(range)))))


range_labels <- tibble::tribble(
  ~Study,  ~Time, ~range, ~extent,
  "TimePoint1", 1250, "95^th~vs.~05^th",  .485,
  "TimePoint3", 1400, "75^th~vs.~25^th",  .09,
  "TimePoint3", 1350, "95^th~vs.~05^th",  .28,
  "TimePoint1", 1300, "75^th~vs.~25^th",  .23) %>% 
  mutate(
    Study = convert_study_to_age(Study),
    range = factor(range, levels = unique(rev(sort(range))))) 

ggplot(by_draw %>% mutate(Study = convert_study_to_age(Study))) +
  aes(x = Time, y = extent, color = Study) +
  geom_point() + 
  geom_text(
    aes(label = Study), 
    data = range_labels, 
    family = "Lato Semibold",
    size = 4) +
  facet_wrap("range", labeller = label_parsed) +
  expand_limits(y = .06) +
  scale_color_study() +
  guides(color = "none") +
  labs(
    title = "Ranges of predictions for 1000 new participants",
    x = constants$x_time,
    y = "Difference of percentiles")
```

The developmental pattern of increasing reliability and decreasing
variability was also observed for the growth curve peaks. For the
synthetic participants, the model predicted that individual peak
probabilities will increase each year, peak<sub>3</sub> =
`r new_peaks_pts$Age3` [90% UI: `r new_peaks_uis$Age3`],
peak<sub>4</sub> = `r new_peaks_pts$Age4` [`r new_peaks_uis$Age4`],
peak<sub>5</sub> = `r new_peaks_pts$Age5` [`r new_peaks_uis$Age5`].
Moreover, the range of plausible values for the individual peaks
narrowed each for the simulated data. For instance, the difference
between the 95^th^ and 5^th^ percentiles was `r new_peaks_diff$Age3` for
age 3, `r new_peaks_diff$Age4` for age 4, and `r new_peaks_diff$Age5`
for age 5.

**Summary**. I used the model's random effects estimates to simulate
growth curves from 1,000 hypothetical, unobserved participants. The
simulated dataset showed increasing looking probability and decreasing
variability with each year of the study. These simulations confirmed the
hypothesis that variability would diminish as children began to demonstrate 
a mature degree of performance for this task.



Are individual differences stable over time?
------------------------------------------------------------------------

```{r compute-kendalls, include = FALSE}
fits <- readr::read_csv("./data/aim1-gca-features.csv.gz")

# Compute Kendall's coefficient of correspondence
tidy_kendall <- . %>%
  unclass() %>%
  as.data.frame(stringsAsFactors = FALSE)

# Add random ratings
new_coef <- fits %>%
  filter(coef == "intercept") %>%
  mutate(
    .posterior_value = runif(length(.posterior_value)),
    coef = "random values")

# Keep only data from participants who visited all three years
reduced_data <- fits %>%
  bind_rows(new_coef) %>%
  tidyr::spread(Study, .posterior_value) %>%
  tidyr::drop_na(TimePoint1:TimePoint3) 

n_rated <- n_distinct(reduced_data$ResearchID)

ws <- reduced_data %>%
  select(-ResearchID) %>%
  tidyr::nest(TimePoint1:TimePoint3) %>%
  mutate(ws = purrr::map(data, irr::kendall) %>% purrr::map(tidy_kendall)) %>%
  select(-data) %>%
  tidyr::unnest(ws)

posterior_w <- ws %>%
  select(.draw, coef, value) %>%
  tidyr::spread(coef, value) %>%
  rename(`random numbers` = `random values`) %>%
  select(-.draw)
```

I predicted that children would show stable individual differences such
that children who are faster and more reliable at recognizing words at
age 3 remain relatively faster and more reliable at age 5. To evaluate
this hypothesis, I used Kendall's *W* (the coefficient of correspondence
or concordance). This nonparametric statistic measures the degree of
agreement among *J* judges who are rating *I* items. For these purposes,
the items are the `r n_rated` children who provided reliable eyetracking
for all three years of the study. (That is, I excluded children who only
had reliable eyetracking data for one or two years.) The judges are the
sets of growth curve parameters from each year of study. For example,
the intercept term provides three sets of ratings: The participants'
intercept terms from year 1 are one set of ratings and the terms from
years 2 and 3 provide two more sets of ratings. These three ratings are
the "judges" used to compute the intercept's *W*. Thus, I computed five
groups of *W* coefficients, one for each set of growth curve features:
intercept, Time^1^, Time^2^, Time^3^, and peak looking probability.


```{r table-example-of-feature-ranks, echo = FALSE, eval = FALSE}
# (_Maybe: Table X illustrates some sample ratings of these participants._)

zero_pad_int <- function(xs) {
  formatter <- paste0("%0", max(nchar(xs)), "d")
  sprintf(formatter, xs)
}

val_rank <- function(xs) {
  a <- printy::fmt_minus_sign(printy::fmt_fix_digits(xs, 2))
  b <- zero_pad_int(rank(-xs))
  glue::glue("{a} ({b})")
}

reduced_data %>% 
  filter(coef == "intercept") %>% 
  group_by(ResearchID, coef) %>% 
  summarise_at(vars(starts_with("TimePoint")), median) %>% 
  ungroup() %>% 
  arrange(desc(TimePoint3)) %>% 
  mutate(
    TimePoint1 = val_rank(TimePoint1), 
    TimePoint2 = val_rank(TimePoint2), 
    TimePoint3 = val_rank(TimePoint3)) %>% 
  rename(
    `Participant ID` = ResearchID,
    `Growth curve feature` = coef,
    `Year 1` = `TimePoint1`,
    `Year 2` = `TimePoint2`,
    `Year 3` = `TimePoint3`) %>% 
  head(10) %>% 
  knitr::kable(align = c("l", "l", "r", "r", "r"))
```

Because I used a Bayesian model, there is a distribution of ratings and
thus a distribution of concordance statistics. Each sample of the
posterior distribution fits a growth curve for each child in each study,
so each posterior sample provides a set of ratings for concordance
coefficients. This distribution of *W*'s lets us quantify our uncertainty
because we can compute *W*'s for each of the `r nsamples` samples from
the posterior distribution.

One final matter is how to assess whether a concordance statistic is
meaningful. To tackle this question, I also included a "null rater", a
fake parameter that assigned each child in each year a random number. I
use the distribution of *W*'s generated by randomly rating children as a
benchmark for assessing whether the other concordance statistics differ
meaningfully from chance.

(ref:kendall-stats) Uncertainty intervals for the Kendall's coefficient of concordance. Random ratings provide a baseline of null *W* statistics. The peak, intercept and linear time features are decisively non-null, indicating a significant degree of correspondence in children's relative word recognition reliability and efficiency over the three years of the study.

```{r kendall-stats, fig.cap = "(ref:kendall-stats)", echo = FALSE, out.width = out_tex100_else80, fig.height = 3, fig.width = 6}
subtitle <- glue::glue(
  "Kendall's W. Raters: 3 timepoints. Items: {n_rated} children.")

w_intervals <- posterior_w %>% 
  rename(
    `Avg.~Probability` = `intercept`, `Time^1` = ot1, `Time^2` = ot2, `Time^3` = ot3,
    `Peak~Probability` = peak_logit, `Random~ratings` = `random numbers`) %>% 
  mcmc_intervals_data(prob_outer = .9, prob = .5) %>% 
  mutate(
    parameter = factor(parameter, c(
      "Random~ratings", "Time^3", "Time^2", "Time^1", "Peak~Probability", "Avg.~Probability"))) 

ggplot(w_intervals) + 
  aes(y = parameter) +
  geom_linerangeh(aes(xmin = ll, xmax = hh)) + 
  geom_linerangeh(aes(xmin = l, xmax = h), size = 2) +
  geom_point(aes(x = m), size = 3, shape = 3) + 
  scale_y_discrete(labels = parse_text) + 
  labs(
    x = NULL, 
    y = NULL, 
    title = "Concordance coefficients for growth curve features",
    caption = constants$cap_median_90_50,
    subtitle = subtitle)

w_pts <- w_intervals %>% 
  split(.$parameter) %>% 
  get_cor_pts()
  
w_uis <- w_intervals %>% 
  split(.$parameter) %>% 
  get_cor_uis()

rm(ws, reduced_data, posterior_w)
```

```{r, eval = FALSE, include = FALSE}
subtitle <- glue::glue(
  "Kendall's W. Raters: 3 time points. Items: {n_rated} children.")

library(extrafont)

w_intervals2 <- w_intervals %>% 
  mutate(
    parameter = factor(parameter, labels = c(
      "Random~ratings", "Time^3", "Time^2", "Time^1", 
      "Average~probability", "Peak~probability"))) 

ggplot(w_intervals2) + 
  aes(y = parameter) +
  geom_linerangeh(aes(xmin = ll, xmax = hh)) + 
  geom_linerangeh(aes(xmin = l, xmax = h), size = 2) +
  geom_point(aes(x = m), size = 3, shape = 3) + 
  scale_y_discrete(labels = parse_text) + 
  theme_grey(base_size = 18, base_family = "Lato") +
  labs(
    x = NULL, 
    y = NULL, 
    title = "Concordance coefficients for growth curve features",
    caption = constants$cap_median_90_50,
    subtitle = subtitle) 
```


I used the `kendall()` function in the irr R package
[vers. `r packageVersion("irr")`; @irr] to compute concordance
statistics. Figure \@ref(fig:kendall-stats) depicts uncertainty intervals
for the Kendall *W*'s for these growth curve features. The 90%
uncertainty interval of *W* statistics from random ratings,
[`r w_uis[["Random~ratings"]]`], subsumes the intervals for the Time^2^
effect [`r w_uis[["Time^2"]]`] and the Time^3^ effect
[`r w_uis[["Time^3"]]`], indicating that these values do not
differentiate children in a longitudinally stable way. Earlier, I
claimed that only the intercept, linear time, and peak features have
psychologically meaningful interpretations and that the higher-order
time features mainly act to capture the curvature of the data. These
null concordance statistics support that claim because the Time^2^ and
Time^3^ features differentiate children across studies as well as random
numbers.

Concordance is strongest for the peak feature, *W* =
`r w_pts[["Peak~Probability"]]` [`r w_uis[["Peak~Probability"]]`] and
the intercept term, *W* = `r w_pts[["Avg.~Probability"]]`
[`r w_uis[["Avg.~Probability"]]`], followed by the linear time term,
*W* = `r w_pts[["Time^1"]]` [`r w_uis[["Time^1"]]`]. Because these
values are far removed from the statistics for random ratings, I
conclude that there is a credible degree of correspondence across
studies when ranking children using their peak looking probability,
average look probability (the intercept) or their growth curve slope
(linear time).

**Summary**. Growth curve features measured individual differences in
word recognition performance. By using Kendall's *W* to measure the
degree of concordance among growth curve features over time, I tested
whether individual differences in lexical processing persisted over
development. I found that the peak looking probability, average looking
probability and linear time features were stable over time. Children who
were relatively fast (or reliable) at word recognition at one age were also
relatively fast (or reliable) at other ages too.



Predicting future vocabulary size
------------------------------------------------------------------------

```{r vocab correlations, include = FALSE}
if (!exists("fits")) {
  fits <- readr::read_csv("./data/aim1-gca-features.csv.gz")
}

scores <- readr::read_csv("./data-raw/test_scores.csv") %>% 
  select(
    Study, ResearchID, Age, EVT_GSV, EVT_Standard, PPVT_GSV, PPVT_Standard)

wide_scores <- scores %>% 
  tidyr::gather("Test", "Value", -ResearchID, -Study) %>% 
  tidyr::unite("Col", Study, Test) %>% 
  tidyr::spread(Col, Value)

cor_complete <- function(...) cor(..., use = "pairwise.complete")

vocab_cors <- fits %>% 
  left_join(wide_scores) %>% 
  group_by(Study, coef, .draw) %>% 
  summarise(
    r_TimePoint3_EVT_Standard = .posterior_value %>% 
      cor_complete(TimePoint3_EVT_Standard),
    r_TimePoint3_EVT_GSV = .posterior_value %>% 
      cor_complete(TimePoint3_EVT_GSV),
    r_TimePoint2_PPVT_GSV = .posterior_value %>% 
      cor_complete(TimePoint2_PPVT_GSV),
    r_TimePoint2_PPVT_Standard = .posterior_value %>% 
      cor_complete(TimePoint2_PPVT_Standard)) %>% 
  ungroup()
```

```{r correlation intervals, include = FALSE}
# Compute the intervals of the correlations
c_intervals <- vocab_cors %>%
  tidyr::nest(-Study, -coef) %>% 
  mutate(
    data = data %>% 
      purrr::map(select, -.draw) %>% 
      purrr::map(mcmc_intervals_data, prob = .5, prob_outer = .9)) %>% 
  tidyr::unnest()

# Compute pairwise differences in vocabulary correlations
vocab_cor_diffs <- vocab_cors %>% 
  tidyr::gather("variable", "correlation", -Study, -coef, -.draw) %>% 
  tidyr::nest(Study, .draw, correlation) %>% 
  mutate(data = purrr::map(data, . %>% compare_pairs(Study, correlation))) %>% 
  tidyr::unnest() %>% 
  # Negative the pairwise differences and flip the labels. 
  # E.g., if TP2-TP1 = .2, then make TP1-TP2 = -.2.
  mutate(
    value = -value,
    pair = pair %>% 
           str_replace("TimePoint(\\d)-TimePoint(\\d)", "TP\\2 - TP\\1")) %>% 
  tidyr::spread(pair, value) %>% 
  tidyr::nest(-coef, -variable) %>% 
  mutate(
    data = data %>% 
      purrr::map(select, -.draw) %>% 
      purrr::map(mcmc_intervals_data, prob = .5, prob_outer = .9)) %>% 
  tidyr::unnest() %>% 
  mutate(parameter = as.character(parameter))
  
main_diffs <- c_intervals %>% 
  mutate(
    parameter = as.character(parameter),
    variable = parameter) %>% 
  bind_rows(vocab_cor_diffs %>% mutate(Study = parameter)) %>% 
  filter(coef %in% c("intercept", "ot1", "peak_logit"))

main_diffs$Study <- main_diffs$Study %>% 
  factor(
    c("TimePoint1", "TimePoint2", "TimePoint3", 
      "TP1 - TP2", "TP2 - TP3", "TP1 - TP3"))
```

```{r correlation-texts, include = FALSE}
# EVT Standard at TimePoint3
evt_tp3_diffs <- main_diffs %>% 
  filter(variable == "r_TimePoint3_EVT_Standard")

peak_evt_tp3_data <- evt_tp3_diffs %>% 
  filter(coef == "peak_logit") %>% 
  split(.$Study) 
peak_evt_tp3_pts <- get_cor_pts(peak_evt_tp3_data) 
peak_evt_tp3_uis <- get_cor_uis(peak_evt_tp3_data)

ot1_evt_tp3_data <- evt_tp3_diffs %>% 
  filter(coef == "ot1") %>% 
  split(.$Study)
ot1_evt_tp3_pts <- get_cor_pts(ot1_evt_tp3_data) 
ot1_evt_tp3_uis <- get_cor_uis(ot1_evt_tp3_data)

int_evt_tp3_data <- evt_tp3_diffs %>% 
  filter(coef == "intercept") %>% 
  split(.$Study) 
int_evt_tp3_pts <- get_cor_pts(int_evt_tp3_data) 
int_evt_tp3_uis <- get_cor_uis(int_evt_tp3_data)


# PPVT Standard at TimePoint2
ppvt_tp2_diffs <- main_diffs %>% 
  filter(variable == "r_TimePoint2_PPVT_Standard")

peak_ppvt_tp2_data <- ppvt_tp2_diffs %>% 
  filter(coef == "peak_logit") %>% 
  split(.$Study) 
peak_ppvt_tp2_pts <- get_cor_pts(peak_ppvt_tp2_data)
peak_ppvt_tp2_uis <- get_cor_uis(peak_ppvt_tp2_data)

int_ppvt_tp2_data <- ppvt_tp2_diffs %>% 
  filter(coef == "intercept") %>% 
  split(.$Study) 
int_ppvt_tp2_pts <- get_cor_pts(int_ppvt_tp2_data)
int_ppvt_tp2_uis <- get_cor_uis(int_ppvt_tp2_data)

ot1_ppvt_tp2_data <- ppvt_tp2_diffs %>% 
  filter(coef == "ot1") %>% 
  split(.$Study) 
ot1_ppvt_tp2_pts <- get_cor_pts(ot1_ppvt_tp2_data)
ot1_ppvt_tp2_uis <- get_cor_uis(ot1_ppvt_tp2_data)
```

I hypothesized that individual differences in word recognition at age 3
will be more discriminating and predictive of future language outcomes than
differences at age 4 or age 5. To test this hypothesis, I calculated
the correlations of growth curve features with age 5 expressive
vocabulary size and age 4 receptive vocabulary. (The receptive test was
not administered during the last year of the study for logistical
reasons.) As with the concordance analysis, I computed each of the
correlations for each sample of the posterior distribution to obtain a
distribution of correlations.

Figure \@ref(fig:evt2-gca-cors) shows the correlations of the peak
looking probability, average looking probability and linear time
features with expressive vocabulary size at age 5, and
Figure \@ref(fig:ppvt4-gca-cors) shows analogous correlations for the
receptive vocabulary at age 4. For all cases, the strongest correlations
were found between the growth curve features at age 3.

Growth curve peaks from age 3 correlated with age 5 vocabulary with
*r* = `r peak_evt_tp3_pts$TimePoint1` [90% UI
`r peak_evt_tp3_uis$TimePoint1`], but the concurrent peaks from age 5
showed a correlation of just *r* = `r peak_evt_tp3_pts$TimePoint3`
[`r peak_evt_tp3_uis$TimePoint3`], a difference between age-3 and
age-5 correlations of *r*<sub>3−5</sub> =
`r peak_evt_tp3_pts[["TP1 - TP3"]]`
[`r peak_evt_tp3_uis[["TP1 - TP3"]]`]. A similar pattern held for
lexical processing efficiency values. Linear time features from age 3
correlated with age 5 vocabulary with *r* =
`r ot1_evt_tp3_pts$TimePoint1` [`r ot1_evt_tp3_uis$TimePoint1`],
whereas the concurrent lexical processing values from age 5 only showed
a correlation of *r* = `r ot1_evt_tp3_pts$TimePoint3`
[`r ot1_evt_tp3_uis$TimePoint3`], a difference of *r*<sub>3−5</sub> =
`r ot1_evt_tp3_pts[["TP1 - TP3"]]`
[`r ot1_evt_tp3_uis[["TP1 - TP3"]]`]. For the average looking
probabilities, the correlation for age 3, *r* =
`r int_evt_tp3_pts$TimePoint1` [`r ot1_evt_tp3_uis$TimePoint1`], was
probably only slightly greater than the correlation for age 4,
*r*<sub>3−4</sub> = `r  int_evt_tp3_pts[["TP1 - TP2"]]`
[`r int_evt_tp3_uis[["TP1 - TP2"]]`] but considerably greater than the
concurrent correlation at age 5, *r*<sub>3−5</sub> =
`r  int_evt_tp3_pts[["TP1 - TP3"]]`
[`r int_evt_tp3_uis[["TP1 - TP3"]]`].

(ref:evt2-gca-cors) Uncertainty intervals for the correlations of growth curve features at each timepoint with age-5 expressive vocabulary (EVT-2 standard scores). The bottom rows provide intervals for the pairwise differences in correlations between timepoints. For example, the top row of the left panel is the correlation between age-3 peak probability and age-5 expressive vocabulary.

```{r evt2-gca-cors, fig.cap = "(ref:evt2-gca-cors)", out.width = out_tex100_else80, fig.height = 3, fig.width = 6, echo = FALSE}
study_map <- c(
  "TimePoint1" = "paste(Age, phantom(l), 3)", 
  "TimePoint2" = "paste(Age, phantom(l), 4)", 
  "TimePoint3" = "paste(Age, phantom(l), 5)", 
  "TP1 - TP2" = "paste(Age, phantom(l), 3)-paste(Age, phantom(l), 4)", 
  "TP2 - TP3" = "paste(Age, phantom(l), 4)-paste(Age, phantom(l), 5)", 
  "TP1 - TP3" = "paste(Age, phantom(l), 3)-paste(Age, phantom(l), 5)"
)

plot_names <- c(
  intercept = "Avg. Probability", 
  ot1 = "Linear Time",
  peak_logit = "Peak Probability")

main_diffs <- main_diffs %>% 
  mutate(plot_coef = plot_names[coef] %>% 
           factor(c("Peak Probability", "Avg. Probability", "Linear Time")))

main_diffs %>% 
  filter(variable == "r_TimePoint3_EVT_Standard") %>% 
  mutate(PlotStudy = factor(study_map[Study], levels = rev(study_map))) %>% 
  ggplot() + 
    aes(y = PlotStudy) +
    geom_vline(xintercept = 0, size = 2, color = "white") +
    geom_point(aes(x = m), size = 3, shape = 3) + 
    geom_segment(
      aes(y = PlotStudy, yend = PlotStudy, x = min_x, xend = max_x), 
      data = . %>% 
        group_by(plot_coef) %>% 
        mutate(min_x = min(ll), max_x = max(hh)) %>% 
        ungroup(),
      size = .25, color = "white") +
    ggstance::geom_linerangeh(aes(xmin = ll, xmax = hh)) + 
    ggstance::geom_linerangeh(aes(xmin = l, xmax = h), size = 2) +
    scale_y_discrete(labels = parse_text) + 
    facet_wrap("plot_coef") +
    labs(
      x = NULL, 
      y = " ", 
      caption = constants$cap_median_90_50) + 
    ggtitle(
      "Correlations of curve features and expressive vocabulary at age 5") + 
    theme(title = element_text(size = rel(.9)))
```

Peak looking probabilities from age 3 were strongly correlated with
age 4 receptive vocabulary, *r* = `r peak_ppvt_tp2_pts$TimePoint1`
[`r peak_ppvt_tp2_uis$TimePoint1`], and this correlation was much
greater than the correlation observed for the age 4 growth curve peaks,
*r*<sub>3−4</sub> = `r peak_ppvt_tp2_pts[["TP1 - TP2"]]`
[`r peak_ppvt_tp2_uis[["TP1 - TP2"]]`]. The correlation for age 3
average looking probabilities, *r* = `r int_ppvt_tp2_pts$TimePoint1`
[`r int_ppvt_tp2_uis$TimePoint1`], was greater than the age 4
correlation, *r*<sub>3−4</sub> =
`r int_ppvt_tp2_pts[["TP1 - TP2"]]`
[`r int_ppvt_tp2_uis[["TP1 - TP2"]]`], and the correlation for age 3
linear time features, *r* = `r ot1_ppvt_tp2_pts$TimePoint1`
[`r ot1_ppvt_tp2_uis$TimePoint1`], was likewise greater,
*r*<sub>3−4</sub> = `r ot1_ppvt_tp2_pts[["TP1 - TP2"]]`
[`r ot1_ppvt_tp2_uis[["TP1 - TP2"]]`].

(ref:ppvt4-gca-cors) Uncertainty intervals for the correlations of growth curve features from age 43 and age 44 with age-4 receptive vocabulary (PPVT-4 standard scores). The bottom row shows pairwise differences between the age-3 and age-4 correlations.

```{r ppvt4-gca-cors, fig.cap = "(ref:ppvt4-gca-cors)", out.width = out_tex100_else80, fig.height = 2, fig.width = 6, echo = FALSE}
main_diffs %>% 
  filter(variable == "r_TimePoint2_PPVT_Standard") %>% 
  filter(Study %in% c("TimePoint1", "TimePoint2", "TP1 - TP2")) %>% 
  mutate(PlotStudy = factor(study_map[Study], levels = rev(study_map))) %>% 
  ggplot() + 
    aes(y = PlotStudy) +
    geom_vline(xintercept = 0, size = 2, color = "white") +
    geom_point(aes(x = m), size = 3, shape = 3) + 
    geom_segment(
      aes(y = PlotStudy, yend = PlotStudy, x = min_x, xend = max_x), 
      data = . %>% 
        group_by(plot_coef) %>% 
        mutate(min_x = min(ll), max_x = max(hh)) %>% 
        ungroup(),
      size = .25, color = "white") +
    ggstance::geom_linerangeh(aes(xmin = ll, xmax = hh)) + 
    ggstance::geom_linerangeh(aes(xmin = l, xmax = h), size = 2) +
    scale_y_discrete(labels = parse_text) + 
    facet_wrap("plot_coef") +
    labs(x = NULL, y = " ", caption = constants$cap_median_90_50) + 
    ggtitle(
      "Correlations of curve features and receptive vocabulary at age 4") + 
    theme(title = element_text(size = rel(.9)))
```

**Summary**. Although individual differences in word recognition were
stable over time, early differences were more significant than later
ones. The strongest predictors of future vocabulary size were the growth
curve features from age 3. Of these features, correlations were strongest
for peak looking probabilities.





Discussion
------------------------------------------------------------------------

In the preceding analyses, I examined many aspects of children's
recognition of familiar words. First, I modeled how children's looking
patterns *on average* changed year over year. Children's word
recognition improved each year: The growth curves grew steeper, reached
higher peaks, and increased in their overall average value each year. This
result was unsurprising, but it was valuable because it confirmed that
this word recognition task scaled with development. The task was simple
enough that children could recognize words at age 3 but challenging
enough for children's performance to improve each year.

After establishing how the averages changed each year, I next asked how
variability changed each year. To tackle this question, I used posterior
predictive inference to have the model simulate samples of data, and in
particular, to simulate new participants. The range of performance
narrowed each year, so that children were most variable at age 3 and
least variable at age 5. This result is consistent with a model of
development where children vary widely early on and converge on a more mature
level of performance. From this perspective, word recognition is a skill
where children "grow out" of immature and highly variable performance
patterns. An alternative outcome would have been concerning: Word
recognition differences that expanded with age with some children
falling behind their peers.

Although the range of individual differences decreased with age,
individual differences did not disappear over time. When children at
each age were ranked using growth curve features, I found a high degree
of correspondence among these ratings. Children who were faster or more
accurate at age 3 remained relatively fast or accurate at age 5. Thus,
differences in word recognition were longitudinally stable over the
preschool years. Extrapolating forwards in time, these differences
likely become smaller and smaller and become irrelevant for
everyday listening situations. It is plausible, however, that under
adverse listening conditions, individual differences might re-emerge and
differentiate children's word recognition performance.

Lastly, I analyzed how individual differences in word recognition
features correlated with future vocabulary outcomes. The peak looking
probabilities and growth curve slopes from age 3 showed the strongest
correlations with future vocabulary scores. This finding was remarkable:
Expressive vocabulary scores at age 5, for example, were more strongly
correlated with word recognition data collected two years earlier than
word recognition data collected during the same week. 

We can understand the predictive value of age-3 word recognition
performance from two perspectives. The first interpretation is
statistical. Differences in children's word recognition performance were
greatest at age 3, so word recognition features at age 3 provide more
variance and more information about the children and their future
vocabulary size. The second interpretation is conceptual. Correlations
were strongest for the growth curve peaks. We can think of this feature
as measuring children's maximum word recognition certainty. A child with
a peak of .5, for example, looked the target image half of the time when
they were most certain about the word. Although all of the words used
were familiar to preschoolers, children with higher peaks
knew those words *better*. These children had a stronger foundation for
word-learning than children who show more uncertainty during word
recognition, and as a result, these children had developed larger
vocabularies two years later.

