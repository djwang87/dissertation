# Analyze familiar word recognition

Next steps:

- Model year over year changes.
- Download test scores and individual differences. 
- Analyze individual differences

```{r include = FALSE}
knitr::read_chunk("./helpers.R")
if (interactive()) source("./helpers.R")
```

```{r helpers, message = FALSE, warnings = FALSE}
```

## Data preparation

Earlier we cleaned the data to remove trials with excessive missing data 
and blocks of trials with too few trials. Read in that data.

```{r, message = FALSE, warnings = FALSE}
data <- readr::read_csv("./data/aim1-screened.csv.gz")
```

Downsample into 50 ms bins.

```{r, eval = TRUE}
data <- data %>% 
  select(Study, ResearchID, TrialID:GazeByImageAOI) %>% 
  assign_bins(bin_width = 3, Time, TrialID)

# Compute time at center of each bin
bin_times <- data %>% 
  distinct(Time, .bin) %>% 
  group_by(.bin) %>% 
  mutate(BinTime = round(median(Time), -1)) %>% 
  ungroup()

# Attach bin times
binned <- data %>% 
  left_join(bin_times, by = c("Time", ".bin")) %>% 
  ungroup() %>% 
  select(-Time) %>% 
  rename(Time = BinTime) 

resp_def <- create_response_def(
  primary = "Target",
  others = c("PhonologicalFoil", "SemanticFoil", "Unrelated"),
  elsewhere = "tracked",
  missing = NA
)  
  
d <- binned %>% 
  aggregate_looks(resp_def, Study + ResearchID + Time ~ GazeByImageAOI)

d_m <- d %>% 
  filter(250 <= Time, Time <= 1500) %>% 
  polypoly::poly_add_columns(Time, degree = 3, 
                             scale_width = 1, prefix = "ot")
```

Plot the model-ready data. Use empirical logit because straight log-odds has too
high of values for plotting.

```{r spaghetti-elogit, out.width = "100%", fig.height=2.5, fig.width=6}
ggplot(d_m) + 
  aes(x = Time, y = empirical_logit(Primary, Others)) + 
  geom_line(aes(group = ResearchID), alpha = .2) + 
  stat_smooth() +
  theme_grey(base_size = 9) +
  facet_grid(. ~ Study) + 
  labs(x = "Time after target onset (smoothed to 50 ms bins)", 
       y = "Emp. logit looking to target")
```

## Maximum likelihood results

Fit a maximum likelihood model as a first pass for the analysis. We won't fit
the model automatically (whenever this page is updated). It's too time
consuming. Instead, we do it manually here, and save the results.

```{r, eval = FALSE}
library(lme4)
m <- glmer(
    cbind(Primary, Others) ~
      (ot1 + ot2 + ot3) * Study +
      (ot1 + ot2 + ot3 | ResearchID/Study),
    family = binomial,
    data = d_m)
readr::write_rds(m, "./data/aim1_cubic_model.rds.gz")
```

And reload the saved model here.

```{r cubic-model-fits, out.width = "100%", fig.height=2.5, fig.width=6}
library(lme4)
m <- readr::read_rds("./data/aim1_cubic_model.rds.gz")
arm::display(m)

# f1 <- function(data) {
#   glmer(
#     cbind(Primary, Others) ~
#       (ot1 + ot2 + ot3) +
#       (ot1 + ot2 + ot3 | ResearchID),
#     family = binomial,
#     data = data)
# }
# 
# separate_studies <- d_m %>% 
#   tidyr::nest(-Study) %>% 
#   mutate(model = purrr::map(data, f1))

d_m$cubic_fit <- fitted(m)

ggplot(d_m) + 
  aes(x = Time, y = cubic_fit) + 
  geom_line(aes(group = ResearchID), alpha = .2) + 
  stat_smooth(method = "gam") +
  facet_grid(. ~ Study) + 
    labs(
      x = "Time after target onset (smoothed to 50 ms bins)",
      y = "Proportion looks to target (fitted)") +
  theme_grey(base_size = 9) 
```

What's being captured by the random effects?

```{r cubic-model-fits-ranefs, out.width = "100%", fig.height=2.5, fig.width=6}
predict_y <- function(...) predict(..., type = "response")
d_m$subj_fit <- predict_y(m, re.form = ~ (ot1 + ot2 + ot3 | ResearchID))

ggplot(d_m) + 
  aes(x = Time, y = subj_fit) + 
  geom_line(aes(group = ResearchID), alpha = .2) + 
  facet_grid(. ~ Study) + 
  theme_grey(base_size = 9) +
  labs(
    x = "Time after target onset (smoothed to 50 ms bins)",
    y = "Proportion looks to target (fitted)",
    caption = "Conditioned on Child effects") 

# d_m$study_fit <- predict_y(m, re.form = ~ (ot1 + ot2 + ot3 | Study:ResearchID))
# ggplot(d_m) + 
#   aes(x = Time, y = study_fit) + 
#   geom_line(aes(group = ResearchID), alpha = .2) + 
#   facet_grid(. ~ Study) + 
#   theme_grey(base_size = 9) +
#   labs(
#     x = "Time after target onset (smoothed to 50 ms bins)",
#     y = "Proportion looks to target (fitted)",
#     caption = "Conditioned on Study x Child effects") 
```



```{r cubic-model-raw-fit-corr, out.width = "50%", fig.height=3, fig.width=4}
d_corr <- d_m %>% 
  group_by(Time, Study) %>% 
  summarise(r = cor(Prop, cubic_fit)) 

ggplot(d_corr) + 
  aes(x = Time, y = r, color = Study) + 
  geom_point(shape = 1, size = 3) + 
  ylim(c(.8, 1)) + 
  labs(
    x = "Time after target onset (smoothed to 50 ms bins)",
    y = "Correlation of fitted and observed") + 
  theme_grey(base_size = 9) +
  theme(
    legend.position = c(0.025, 0.05), 
    legend.justification = c(0, 0)) 

  
# ggplot(d_m) + 
#   aes(x = Prop, y = cubic_fit) + 
#   geom_point(shape = 1, alpha = .2) + 
#   geom_abline(color = "blue", size = 2)
#   geom_line(aes(group = ResearchID), alpha = .2) + 
#   stat_smooth() +
#   facet_grid(. ~ Study) + 
#     labs(y = "Proportion looks to target [model fits]", 
#        x = "Time after target onset (smoothed to 50 ms bins)")


# ggplot(inner_join(d_m, ranks),) + 
#   aes(x = Time, y = cubic_fit, color = -slope) + 
#   geom_line(aes(group = ResearchID), alpha = .4) +
#   viridis::scale_color_viridis() + 
#   facet_grid(. ~ Study)
  # geom_line(aes(group = ResearchID), data = semi_join(d_m, top_10), size = 1, color = "blue") + 
  # geom_line(aes(group = ResearchID), data = semi_join(d_m, bot_10), size = 1, color = "red") +
```


Visualize the top and bottom 20 children (pooled over studies).

```{r ranks, out.width = "100%", fig.height=2.5, fig.width=6}
xstudy_effects <- m %>% 
  ranef() %>% 
  getElement("ResearchID") %>% 
  tibble::rownames_to_column("ResearchID") %>% 
  as_tibble() %>% 
  select(ResearchID, intercept = `(Intercept)`, slope = ot1)

top_20 <- top_n(xstudy_effects, 20, slope)
bot_20 <- top_n(xstudy_effects, 20, -slope)

ggplot(d_m) + 
  aes(x = Time, y = cubic_fit) + 
  geom_line(aes(group = ResearchID), alpha = .2) +
  geom_line(aes(group = ResearchID), data = semi_join(d_m, top_20), 
            size = .7, color = "#0074D9") + 
  geom_line(aes(group = ResearchID), data = semi_join(d_m, bot_20), 
            size = .7, color = "#FF4136") + 
  facet_grid(. ~ Study) + 
  theme_grey(base_size = 9) +
  labs(y = "Proportion looks to target [model fits]", 
       x = "Time after target onset (smoothed to 50 ms bins)",
       caption = "Colors: Top 20 and bottom 20 children by linear time effect")
```

Plot the ranks on the raw data.

```{r ranks-on-raw, out.width = "100%", fig.height=2.5, fig.width=6}
ggplot(d_m) + 
  aes(x = Time, y = Prop) + 
  geom_line(aes(group = ResearchID), alpha = .2) +
  geom_line(aes(group = ResearchID), data = semi_join(d_m, top_20), 
            size = .7, color = "#0074D9") + 
  geom_line(aes(group = ResearchID), data = semi_join(d_m, bot_20), 
            size = .7, color = "#FF4136") + 
  facet_grid(. ~ Study) + 
  labs(y = "Proportion looks to target", 
       x = "Time after target onset (smoothed to 50 ms bins)",
       caption = "Colors: Top 20 and bottom 20 children by linear time effect")
```

## Bayesian model results

Here is the code used to fit the model with Stan. It took about 24 hours to run
the model.

```{r, eval = FALSE}
library(rstanarm)
options(mc.cores = parallel::detectCores())

m <- stan_glmer(
  cbind(Primary, Others) ~
    (ot1 + ot2 + ot3) * Study +
    (ot1 + ot2 + ot3 | ResearchID/Study),
  family = binomial,
  prior = normal(0, 1),
  prior_intercept = normal(0, 5),
  prior_covariance = decov(2, 1, 1),
  data = d_m)
readr::write_rds(m, "./data/stan_aim1_cubic_model.rds.gz")
```

Let's try to understand our model by making some plots.

### Fixed effects plots

First, let's prepare to plot the intervals for the fixed effects.

```{r}
library(rstanarm)
library(bayesplot)
theme_set(theme_grey())
library(stringr)
library(ggstance)
parse_text <- function(x) parse(text = x)

b <- readr::read_rds("./data/stan_aim1_cubic_model.rds.gz")
b

intervals <- mcmc_intervals_data(as.data.frame(b), pars = names(fixef(b)))

# Rename to use mathematical formatting
intervals$pname <- intervals$parameter %>%
  str_replace("ot(2|3)", "Time^\\1") %>% 
  str_replace("ot(1)", "Time") %>% 
  str_replace(".Intercept.", "Intercept") %>% 
  str_replace("Study", "") %>% 
  str_replace(":", " %*% ") %>% 
  factor(., levels = rev(.))
```

Below the TimePoint2, TimePoint3, Time x TimePoint2, and Time x TimePoint3 
effects confirm that children get more reliable and faster each year of the 
study. Only the Time^2^ effect is near 0, which does not matter. We mostly care
about the intercept and time terms.

```{r effects1, out.width = "80%", fig.height=4, fig.width=5}
ggplot(intervals) + 
  aes(y = pname) +
  geom_vline(xintercept = 0, size = 2, color = "white") +
  geom_linerangeh(aes(xmin = ll, xmax = hh)) + 
  geom_linerangeh(aes(xmin = l, xmax = h), size = 2) +
  geom_point(aes(x = m), size = 3, shape = 3) + 
  scale_y_discrete(labels = parse_text) + 
  labs(x = NULL, y = NULL, caption = "90% and 50% intervals") + 
  ggtitle("Average effects")
```

Now, let's undo interactions by adding year 1 main effects to interaction 
effects and plot the effects for each year of the study. For each effect, there
appears to be a linear trend in the change from TP1 to TP2 and from TP2 to TP3.

```{r effects2, out.width = "80%", fig.height=4, fig.width=5}
# Column names will have mathematical formatting too
draws <- as.data.frame(b) %>% 
  as_tibble() %>% 
  transmute(
    `Intercept~~(TP1)` = `(Intercept)`,
    `Intercept~~(TP2)` = `(Intercept)` + StudyTimePoint2,
    `Intercept~~(TP3)` = `(Intercept)` + StudyTimePoint3,
    `Time~~(TP1)` = ot1,
    `Time~~(TP2)` = ot1 + `ot1:StudyTimePoint2`,
    `Time~~(TP3)` = ot1 + `ot1:StudyTimePoint3`,
    `Time^2~~(TP1)` = ot2,
    `Time^2~~(TP2)` = ot2 + `ot2:StudyTimePoint2`,
    `Time^2~~(TP3)` = ot2 + `ot2:StudyTimePoint3`,
    `Time^3~~(TP1)` = ot3,
    `Time^3~~(TP2)` = ot3 + `ot3:StudyTimePoint2`,
    `Time^3~~(TP3)` = ot3 + `ot3:StudyTimePoint3`)

intervals2 <- mcmc_intervals_data(draws) %>% 
  mutate(parameter = factor(parameter, levels = rev(parameter)))

ggplot(intervals2) + 
  aes(y = parameter) +
  geom_vline(xintercept = 0, size = 2, color = "white") +
  ggstance::geom_linerangeh(aes(xmin = ll, xmax = hh)) + 
  ggstance::geom_linerangeh(aes(xmin = l, xmax = h), size = 2) +
  geom_point(aes(x = m), size = 3, shape = 3) + 
  scale_y_discrete(labels = parse_text) + 
  labs(x = NULL, y = NULL, caption = "90% and 50% intervals") + 
  ggtitle("Average effects by study")
```

Bayesplot supports transformations so we could invert the log-odds measure to
see the intercepts (area under curve/average accuracy) in proportion units.

```{r intercepts, out.width = "60%", fig.height=2.5, fig.width=4}
intervals3 <- mcmc_intervals_data(draws, regex_pars = "Intercept", 
                                  transformations = "plogis") %>% 
  mutate(parameter = factor(parameter, levels = rev(parameter)))

intervals3 %>% 
  mutate_if(is.numeric, round, 3) %>% 
  select(-point_est) %>% 
  rename(outer = outer_width, inner = inner_width) %>% 
  knitr::kable()

ggplot(intervals3) + 
  aes(y = parameter) +
  geom_vline(xintercept = .25, size = 2, color = "white") +
  ggstance::geom_linerangeh(aes(xmin = ll, xmax = hh)) + 
  ggstance::geom_linerangeh(aes(xmin = l, xmax = h), size = 2) +
  geom_point(aes(x = m), size = 3, shape = 3) + 
  scale_y_discrete(labels = parse_text) + 
  labs(x = NULL, y = NULL, caption = "90% and 50% intervals") + 
  ggtitle("Average accuracy by year")
```

### Posterior predictive checks

Next, we let's check how well the model can simulate the observed data.

```{r post-pred, out.width = "80%", fig.height=3, fig.width=5}
rstanarm::pp_check(b, nreps = 200, seed = "09272017") + 
  labs(
    x = "Proportion of looks", 
    title = "Observed data and 200 posterior simulations") +
  guides(color = "none") +
  coord_cartesian(xlim = c(0, 1))
```


### Look at some predictions

Plot the posterior predictions for random participants. This is the model 
simulating new data for these participants.

```{r posterior-lines, out.width = "100%", fig.height=4, fig.width=5}
set.seed(09272017)

ppred <- d_m %>% 
  sample_n_of(8, ResearchID) %>% 
  tristan::augment_posterior_predict(b, newdata = ., nsamples = 100) %>% 
  mutate(trials = Primary + Others)

ggplot(ppred) + 
  aes(x = Time, y = Prop, color = Study, group = Study) + 
  geom_line(aes(y = .posterior_value / trials, 
                group = interaction(.draw, Study)), 
            alpha = .20) + 
  geom_line(size = 1, color = "grey50") + 
  facet_wrap("ResearchID") + 
  theme(
    legend.position = c(.95, 0), 
    legend.justification = c(1, 0),
    legend.margin = margin(0)) +
  guides(color = guide_legend(title = NULL, override.aes = list(alpha = 1))) +
  labs(
    title = "Observed means and 100 simulations of new data",
    x = "Time after target onset",
    y = "Proportion looks to target") 
```

Or we can plot the linear predictions. These are posterior predictions of the
log-odds of looking to target before adding binomial noise.

```{r posterior-mean-lines, out.width = "100%", fig.height=4, fig.width=5}
lpred <- d_m %>% 
  sample_n_of(8, ResearchID) %>% 
  tristan::augment_posterior_linpred(b, newdata = ., nsamples = 100)

ggplot(lpred) + 
  aes(x = Time, y = .posterior_value, color = Study) +
  geom_line(aes(group = interaction(Study, ResearchID, .draw)), 
            alpha = .1) +
  facet_wrap("ResearchID") + 
  geom_point(aes(y = qlogis(Prop)), shape = 1) + 
  theme(
    legend.position = c(.95, 0), 
    legend.justification = c(1, 0),
    legend.margin = margin(0)) +
  guides(color = guide_legend(title = NULL, override.aes = list(alpha = 1))) +
  labs(
    title = "Observed data and 100 posterior predictions",
    x = "Time after target onset",
    y = "Posterior log-odds")
```


### Plot the intervals for the covariances

These are the parameters governing the random effect distributions.

```{r posterior-sds, out.width = "80%", fig.height=2.5, fig.width=5}
sdcors <- tristan::draw_var_corr(b)
sdcors_wide <- sdcors %>% 
  select(.draw, .parameter, sdcor) %>% 
  tidyr::spread(.parameter, sdcor) %>% 
  select(-.draw)

# Create the mathematical labels for parameters
group_info <- sdcors %>% 
  select(.parameter:var2) %>% 
  distinct()
group_info$group <- group_info$grp %>% 
  stringr::str_replace("Study:ResearchID", "Child-Study") %>% 
  stringr::str_replace("ResearchID", "Child") 
group_info$r <- ifelse(is.na(group_info$var2), "", 
                       paste0(",", group_info$var2))
group_info$sym <- ifelse(is.na(group_info$var2), "sigma", "rho")
group_info$var1 <- ifelse(group_info$var1 == "(Intercept)", "Intercept", 
                          group_info$var1)
group_info$math <- sprintf("%s[list(%s%s)]", group_info$sym, 
                           group_info$var1, group_info$r)
group_info$class <- ifelse(is.na(group_info$var2), "scale", "correlation")
group_info <- group_info %>% 
  select(group, class, var1, var2, parameter = .parameter, math) %>% 
  mutate(parameter = as.factor(parameter))

intervals <- as.data.frame(sdcors_wide) %>% 
  mcmc_intervals_data() %>% 
  left_join(group_info, by = "parameter") %>% 
  mutate(math = forcats::fct_rev(math))

ggplot(intervals %>% filter(class == "scale")) + 
  aes(y = math) +
  # Draw medians with + then draw white horizontal lines over the horizontal 
  # parts of the + symbols
  geom_point(aes(x = m), size = 3, shape = 3) +
  geom_hline(aes(yintercept = as.numeric(parameter)), color = "white") +
  geom_linerangeh(aes(xmin = ll, xmax = hh)) + 
  geom_linerangeh(aes(xmin = l, xmax = h), size = 2) +
  scale_y_discrete(labels = parse_text) +
  facet_wrap("group", ncol = 1, strip.position = "left") + 
  theme(strip.placement = "outside", 
        strip.background = element_rect(fill = NA),
        axis.text.y = element_text(size = rel(1.2))) +
  labs(title = "Random effect scales", 
       x = NULL, y = NULL, 
       caption = "90% and 50% intervals")
```

```{r posterior-cors, out.width = "80%", fig.height=3, fig.width=5}
ggplot(intervals %>% filter(class == "correlation")) + 
  aes(y = math) +
  geom_vline(xintercept = 0, size = 2, color = "white") +
  # Draw medians with + then draw white horizontal lines over the horizontal 
  # parts of the + symbols
  geom_point(aes(x = m), size = 3, shape = 3) +
  geom_hline(aes(yintercept = as.numeric(parameter)), color = "white") +
  geom_linerangeh(aes(xmin = ll, xmax = hh)) + 
  geom_linerangeh(aes(xmin = l, xmax = h), size = 2) +
  scale_y_discrete(labels = parse_text) +
  facet_wrap("group", ncol = 1, strip.position = "left") + 
  theme(strip.placement = "outside", 
        strip.background = element_rect(fill = NA),
        axis.text.y = element_text(size = rel(1.2))) +
  labs(title = "Random effect correlations", 
       x = NULL, y = NULL, 
       caption = "90% and 50% intervals")
```

